#打卡！！！！！！！
###2018-2-27√  2018-2-28√ 



###2017-12-25

```
在部分插件或者自身插件需要绑定input标签，未避免该Input导致键盘弹起可以给其一个readyonly属性
```
###2018-02-06
```
processData: false,
contentType: false,
以上两段用于修改post请求发送时避免受jquery默认属性影响
```
##ios兼容问题
```
无法在input框中自行使用focus进行解决
直接调focus会导致ios拦截。设置另一个按钮监听addEventListener进行触发可以解决该问题
```

##闭包就是函数在作用过程中产生的内存空间
```js
(function(global,factory){
    //该内存空间中可以保护我们需要使用的变量
}(typeof window !=="undefined" ? window : this ,function(window,noGlobal){
    
}))
    /**
     * typeof window !=="undefined" ? window : this 
     * 浏览器中这部分内容不必要，直接传入this，当this没有规定指向时。this即是window
     * 当jquery不使用于浏览器时，而是使用在node中，可以用于解析xml。此时window确实不存在
     */
```
###java，21天从入门到放弃！！！坚持21天			

- day1-day2:
  - 1.java中单引号之间只能放一个字符,双引号之间能放多个如'1','a'
  - 2.$和_可以在变量申明时使用其他标点不允许
  - 3.类和接口名首字母要以驼峰命名法大写，方法和变量从第二个单词开始大写，第一个单词小写
  - 4.常量命名全体大写且两个单词间_下划线分隔，MAX_VAL
  - 5.二进制的电信号把8个开关规定为一个字节byte，每个开关就是一个比特位bit,现在称谓数字信号用0和1表示，再后来出现了1k = 1024byte; 1m = 1024k; 1G = 1024m 1t = 1024G
    - 硬盘中的500G 为厂商以1000为单位，计算机以1024为单位因此缩水；500*1000 *1000 *1000 byte / 1024/1024/1024 = 465G 
    - 由于2进制的表示过长，产生了8进制和16进制取代2进制，更短
    - 二进制0b开头 ； 八进制0开头；十六进制0X开头；
    - 十进制转其他进制，除积倒取余的方法
    - 二进制转8进制，分为3个3个进位。二进制转16进制 每4位进行转化
  - 6.原码反码补码： 
    - 原码最高位 0 表示正数，1表示负数
    - 正数的反码与其本身相同，负数的反码对其逐级取反，除了符号位之外
    - 正数的补码与其本身相同，负数的补码在其最末尾加1
    - 正数和负数之和计算规则
      - ​
  ```
  0 0000111   +7(原码)         0 0000111    +7(反码相同)          0 0000111  +7(补码相同)
  1 0000111   -7(原码) ======》1 1111000    -7(反码)     ======》 1 1111001  -7(补码)
  ------------------											  ----------
  															 10 0000000 (超出8位的1去掉得出0)		
  计算过程：1.正数不变，负数的符号位不变其他位置逐位取反 (求反码 )
  		 2.正数不变，负数的补码是在反码基础上的末尾加1 (求补码)

  ```
  - 7.数据类型
    - 基本数据类型
      - 整数型 
        - byte一个字节 (-128~+127)
        - short两个字节(-2^15~2^15-1)
        - int四个字节 (-2^31~2^31-1)
        - long八个字节(-2^63~2^63-1)
      - 浮点型
        - float 四个字节，单精度
        - double八个字节，双精度
      - 字符型
        - char 占两个字节 0~65535
      - 布尔类型
        - 无法进行运算，理论上占八分之一个字节，java没有明确规定大小
      - 隐式转化
        - 1.byte b = 4;  int x = 3;  x = x+b;
        - 2.byte b = 4;  int x = 3;  b = x+b;
        - 3.两个byte相加，会先转为Int类型再转为byte 可能损失精度

      ```
      byte b=====> 00000100         int x =======> 00000000 00000000 0000000 00000011
      过程1：byte b 会先转为int类型0000000 0000000 0000000 00000100，再与x相加
      ```

      ```
      2.两者运算后为int型，四个字节想要赋值给byte类型，要去掉前三个八位强制转换。b = (byte)(x+b)
      	强制转换时可能把正数变为负数。计算过程中都以补码进行，因此可以先-1获得反码再取反
      	
      ```

  - 8.字符和字符运算ASCII码表

    - ’a‘+1 outprintln 为98;   

      ​
  - 9.运算
    - 	整数相除只能得整数，想要得到小数需要把其中一个变为小数
        - ​